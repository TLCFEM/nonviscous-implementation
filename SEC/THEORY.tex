\section{Basics}
\subsection{Nonviscously Damped System}
Consider the equation of motion of a nonviscously damped inelastic multi-degree-of-freedom (MDOF) system,
\begin{gather}\label{eq:eom}
\mb{y}\left(\bu,\bv,\ba\right)+\bbf\left(t\right)=\mb{p}\left(t\right),
\end{gather}
where $\bu=\bu\left(t\right)$, $\bv=\bv\left(t\right)=\dot{\bu}$ and $\ba=\ba\left(t\right)=\dot{\bv}$ are the displacement, velocity and acceleration vectors, $\mb{y}=\mb{y}\left(\bu,\bv,\ba\right)$ is the resistance vector of the system, $\mb{p}=\mb{p}\left(t\right)$ is the external load vector, and $\bbf$ is the nonviscous damping force which can be expressed in the form of the convolution of the kernel $g=g\left(t\right)$ and the vector $\bw$, viz. $\bbf\left(t\right)=g*\bw$.

Note here, $\bw$ can be either the exact velocity vector $\bv$, or the subset of $\bv$ such that they share the same size but some velocity components in $\bv$ are replaced by zeros in $\bw$ on selected DoFs. This is beneficial when it comes to compositing flexible damping that will be discussed later in this work. Formally, it can be represented by
\begin{gather}
\bw=\mb{T}\bv,
\end{gather}
where $\mb{T}$ is a square diagonal matrix, the diagonal entries of which are either one or zero.

Since it is an inelastic system, the stiffness matrix $\mb{K}$, the viscous damping matrix $\mb{C}$ and the mass matrix $\mb{M}$ are
\begin{gather}
\pdfrac{\mb{y}}{\bu}=\mb{K},\qquad
\pdfrac{\mb{y}}{\bv}=\mb{C},\qquad
\pdfrac{\mb{y}}{\ba}=\mb{M}.
\end{gather}
The viscous damping matrix $\mb{C}$ may not be trivial as the system may consist of viscous damping components (e.g., viscous damper devices). Using $\bu$ as the basic quantity, the effective stiffness matrix $\bbar{K}$
\begin{gather}
\bbar{K}=\ddfrac{\mb{y}}{\bu}=\mb{K}+\mb{C}\ddfrac{\bv}{\bu}+\mb{M}\ddfrac{\ba}{\bu}
\end{gather}
is the combination of the three, its specific form depends on the specific time integration method used.
\section{Nonviscous Damping With A Single Exponential Kernel}
\subsection{A Single Exponential Kernel}
We start with the scalar-valued exponential kernel function
\begin{gather}
g=g\left(t\right)=m\exp\left(-st\right),
\end{gather}
where $s$ is often denoted by the relaxation parameter $\mu$, $m$ is often denoted by $c\mu$ in which $c$ is the damping constant. In this work, $s$ and $m$ are adopted for brevity.
The convolution can be then expressed as
\begin{gather}\label{eq:single_conv}
\bbf\left(t\right)=g*\bw=\int_0^tg(t-\tau)\cdot\bw\left(\tau\right)~\md{\tau}=\int_0^tm\exp\left(-s\left(t-\tau\right)\right)\cdot\bw\left(\tau\right)~\md{\tau}.
\end{gather}
\eqsref{eq:single_conv} corresponds to the solution of the following ODE \citep[see, e.g.,][\S~80]{Zwillinger2021},
\begin{gather}\label{eq:single_conv_ode}
\bbf'=-s\bbf+m\bw.
\end{gather}
It can be validated by solving \eqsref{eq:single_conv_ode} with the assist of the integrating factor $\exp\left(st\right)$.
\subsection{An Efficient Algorithm}
Instead of directly integrating \eqsref{eq:single_conv} using higher-order methods (such as the Runge--Kutta family), \eqsref{eq:single_conv_ode} can be combined with \eqsref{eq:eom} to develop an efficient algorithm.

Given that popular time integration methods are of second order accuracy, in the context of a discretised iterative solving schema, \eqsref{eq:single_conv_ode} can be rewritten as follows using Heun's method, which is second order accurate, accordingly,
\begin{gather}
\tilde{\bbf}_{n+1}=\bbf_n+\Delta{}t\left(-s\bbf_n+m\bw_n\right),\\
\bbf_{n+1}=\bbf_n+\dfrac{\Delta{}t}{2}\left(-s\bbf_n+m\bw_n-s\tilde{\bbf}_{n+1}+m\bw_{n+1}\right).
\end{gather}
Expanding and rearranging lead to
\begin{gather}
\bbf_{n+1}=
\left(1-s\Delta{}t+\dfrac{s^2\Delta{}t^2}{2}\right)\bbf_n
+\dfrac{m\Delta{}t}{2}\left(1-s\Delta{}t\right)\bw_n
+\dfrac{m\Delta{}t}{2}\bw_{n+1}.
\end{gather}

In the context of a discretised iterative solving scheme, \eqsref{eq:single_conv_ode} can be rewritten as follows using the backward (implicit) Euler method,
\begin{gather}\label{eq:discretised_a}
\dfrac{\bbf_{n+1}-\bbf_n}{\Delta{}t}=-s\bbf_{n+1}+m\bw_{n+1},
\end{gather}
in which subscripts $\left(\cdot\right)_{n+1}$ and $\left(\cdot\right)_n$ denote the corresponding quantity at $t_n$ and $t_{n+1}=t_n+\Delta{}t$.
Rearranging \eqsref{eq:discretised_a} yields
\begin{gather}\label{eq:discretised_b}
\left(1+s\Delta{}t\right)\bbf_{n+1}-\bbf_n-m\Delta{}t\bw_{n+1},
\end{gather}
thus
\begin{gather}\label{eq:discretised_c}
\bbf_{n+1}=\dfrac{1}{1+s\Delta{}t}\bbf_n+\dfrac{m\Delta{}t}{1+s\Delta{}t}\bw_{n+1}.
\end{gather}

It must be pointed out that the idea to introduce an internal variable is similar to the approach presented by \citet[][see \S~4.3]{Adhikari2014}. In this work, instead of the filtered velocity \citep[][see Eq. 4.23]{Adhikari2014}, the nonviscous damping force is chosen as the internal variable, which, as can be seen later, eventually leads to a system that can be effectively solved.

Assuming \eqsref{eq:eom} is satisfied at $t_{n+1}$\footnote{This assumption is not always valid as some time integration methods establish the EOM elsewhere, see, for example, the generalised-$\alpha$ method, the GSSSS method, the Bathe two-step method, the OALTS method, etc.}, then, accounting for \eqsref{eq:discretised_c}, \eqsref{eq:eom} (with the subscript $\left(\cdot\right)_{n+1}$ dropped for brevity) is
\begin{gather}\label{eq:residual}
\mb{y}+\dfrac{1}{1+s\Delta{}t}\bbf_n+\dfrac{m\Delta{}t}{1+s\Delta{}t}\bw=\mb{p}.
\end{gather}
Differentiation leads to the following revised effective stiffness $\bhat{K}$,
\begin{gather}\label{eq:revised_k}
\bhat{K}=\bbar{K}+\dfrac{m\Delta{}t}{1+s\Delta{}t}\mb{T}\ddfrac{\bv}{\bu}.
\end{gather}
Typically, $\ddfrac{\bv}{\bu}$ reduces to a scalar constant (multiplied by an identity matrix), for example, in the Newmark method, it is $\dfrac{\gamma}{\beta\Delta{}t}$.

By introducing the revised resistance $\bhat{y}$ as
\begin{gather}\label{eq:revised_y}
\bhat{y}=\mb{y}+\dfrac{1}{1+s\Delta{}t}\bbf_n+\dfrac{m\Delta{}t}{1+s\Delta{}t}\bw,
\end{gather}
the final system to be solved is
\begin{gather}\label{eq:revised_system}
\bhat{K}\delta\bu=\mb{q}-\bhat{y}.
\end{gather}

The local iteration body is summarised in \algoref{algo:single_model}.
\begin{breakablealgorithm}
\setstretch{1.8}
\caption{iteration body of solving nonviscously damped system with one exponential kernel}\label{algo:single_model}
\begin{algorithmic}
\State \textbf{Input}: $\bbar{K}$, $\bu$, $\bv$, $\mb{y}$, $\mb{p}$ (quantities obtained via conventional manner as if there is no nonviscous damping) and $\bbf_n$
\State \textbf{Output}: $\bu$
\State compute $\bw$ from $\bv$
\State \faMicrochip~compute revised stiffness $\bhat{K}=\bbar{K}+\dfrac{m\Delta{}t}{1+s\Delta{}t}\mb{T}\ddfrac{\bv}{\bu}$\Comment{\eqsref{eq:revised_k}}
\State \faMicrochip~compute revised resistance $\bhat{y}=\mb{y}+\dfrac{1}{1+s\Delta{}t}\bbf_n+\dfrac{m\Delta{}t}{1+s\Delta{}t}\bw$\Comment{\eqsref{eq:revised_y}}
\State $\delta\bu=\bhat{K}^{-1}\left(\mb{p}-\bhat{y}\right)$\Comment{\eqsref{eq:revised_system}}
\State update and return $\bu\leftarrow\bu+\delta\bu$
\end{algorithmic}
\end{breakablealgorithm}
The steps with a leading \faMicrochip~symbol augment global effective stiffness and resistance to obtain $\bhat{K}$ and $\bhat{y}$. Those are additional steps that need to be computed compared to a conventional algorithm for nonviscously damped systems. Once convergence is achieved, it is necessary to store the history of nonviscous damping force $\bbf_n\leftarrow\bbf$.

Unlike other algorithms, such as the one by \citet{Cortes2009}, \algoref{algo:single_model} does not impose additional requirements to the time integration method used.
\subsection{Complexity Analysis}
The term $\mb{T}\ddfrac{\bv}{\bu}\delta\bu$ can be efficiently computed by masking $\delta\bu$ as $\mb{T}$ is a diagonal matrix while $\ddfrac{\bv}{\bu}$ can be equivalently converted into a scalar (see discussion before). Assuming the system has a size of $n$, it requires at most $n$ floating point number arithmetic. All three extra steps require pure vector operations, the total number of floating point number multiplications is $6n$, that is a time complexity of $\mathcal{O}\left(n\right)$.

\algoref{algo:single_model} requires no memory reallocation, the additional storage needed is for the nonviscous damping forces $f_n$, implying a space complexity of $\mathcal{O}\left(n\right)$.
\section{Nonviscous Damping With Arbitrary Kernel}
\subsection{Sum of Exponentials}
Now consider, instead of a single exponential function, multiple exponential functions such that
\begin{gather}\label{eq:sum_exp}
g=\sum_{l=1}^{j}g_l\left(t\right)=\sum_{l=1}^{j}m_l\exp\left(-s_lt\right),
\end{gather}
where $m_l$ and $s_l$ can be complex numbers, then
\begin{gather}\label{eq:sum_conv}
\bbf\left(t\right)=g*\bw=\sum_{l=1}^{j}g_l\left(t\right)*\bw=\sum_{l=1}^{j}\bbf_l.
\end{gather}
For each of $\bbf_l$, \eqsref{eq:discretised_b} also holds and only involves $\bbf_l$ itself and the common quantity $\bw$. Thus,
\begin{gather}
\bbf_l=\dfrac{1}{1+s_l\Delta{}t}\bbf_{l,n}+\dfrac{m_l\Delta{}t}{1+s_l\Delta{}t}\bw.
\end{gather}

Similar to the single function case, substituting $\bbf_l$ into \eqsref{eq:eom}, differentiation yields the revised stiffness
\begin{gather}\label{eq:revised_k_multi}
\bhat{K}=\bbar{K}+\sum_{l=1}^{j}\dfrac{m_l\Delta{}t}{1+s_l\Delta{}t}\mb{T}\ddfrac{\bv}{\bu},
\end{gather}
and the revised resistance
\begin{gather}\label{eq:revised_y_multi}
\bhat{y}=\mb{y}+\sum_{l=1}^{j}\dfrac{1}{1+s_l\Delta{}t}\bbf_{l,n}+\sum_{l=1}^{j}\dfrac{m_l\Delta{}t}{1+s_l\Delta{}t}\bw.
\end{gather}

Noting that within each sum, the operations performed are identical to that in the single function case, the complexity in this case is $\mathcal{O}\left(jn\right)$ for both time and space.
\subsection{Arbitrary Kernel}
\citet{Gao2022} presented a method to approximate a given arbitrary function $g\left(t\right)$ with arbitrary accuracy within a given interval, using multiple exponential functions, that is
\begin{gather}
\max_{t\in{}I}{\abs{g\left(t\right)-\sum_jm_j\exp\left(-s_jt\right)}}<\epsilon,
\end{gather}
where $I$ is a finite interval that could be an arbitrary subset of $\mathbb{R}^+$, $\epsilon$ is the error tolerance.

By assigning a tolerance close to (or less than) the machine error, an accurate equivalence of arbitrary kernel function can be obtained for nonviscous damping computation. In practice, such a tolerance only needs to be smaller than analysis tolerance.
\subsection{Composition of Damping}
It is possible to further assign multiple arbitrary kernels to different subsets of velocity vector. Formally,
\begin{gather}
\bbf=\sum_{k=1}^{i}g^k\bw^k,
\end{gather}
where $g^k$ is the arbitrary kernel applied to $\bw^k$,
\begin{gather}
g^k=\sum_{l=1}^{j^k}g_l^k\left(t\right)=\sum_{l=1}^{j^k}m_l^k\exp\left(-s_l^kt\right),
\end{gather}
in its explicit form
\begin{gather}\label{eq:composition}
\bbf=\sum_{k=1}^{i}\sum_{l=1}^{j^k}\bbf_l^k=\sum_{k=1}^{i}\sum_{l=1}^{j^k}g_l^k\left(t\right)\bw^k=\sum_{k=1}^{i}\sum_{l=1}^{j^k}m_l^k\exp\left(-s_l^kt\right)\bw^k.
\end{gather}

Since additivity still holds, there is no essential difference between \eqsref{eq:sum_exp} and \eqsref{eq:composition}. $m_l^k$ and $s_l^k$ are parameters for $l$-th component of $k$-th kernel. $\bw^k=\mb{T}^k\bv$ can be obtained by either node-based or element-based rules. For the former, it is assumed different regions (characterised by nodes) possess different damping response. For the latter, it is assumed different elements possess different damping response, similar to a typical assembly process. No matter how $\bw^k$ is constructed, the revised stiffness and resistance for each $\bbf_l^k$ only require vector--scalar operation.

Denoting
\begin{gather}
j^\text{max}=\max_{k\in\{1,2,\cdots,i\}}\left(j^k\right),
\end{gather}
the time and space complexity is $\mathcal{O}\left(ij^\text{max}n\right)$.
